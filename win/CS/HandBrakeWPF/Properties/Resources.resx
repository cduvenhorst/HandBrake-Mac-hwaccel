<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Advanced_AdaptiveBFramesToolTip" xml:space="preserve">
    <value>x264 has a variety of algorithms to decide when to use B-frames and how many to use.

Fast mode takes roughly the same amount of time no matter how many B-frames you specify.  However, while fast, its decisions are often suboptimal.

Optimal mode gets slower as the maximum number of B-Frames increases, but makes much more accurate decisions, especially when used with B-pyramid.</value>
  </data>
  <data name="Advanced_AdaptiveDirectModeToolTip" xml:space="preserve">
    <value>H.264 allows for two different prediction modes, spatial and temporal, in B-frames.

Spatial, the default, is almost always better, but temporal is sometimes useful too.

x264 can, at the cost of a small amount of speed (and accordingly for a small compression gain), adaptively select which is better for each particular frame.</value>
  </data>
  <data name="Advanced_AdaptiveQuantizationStrengthToolTip" xml:space="preserve">
    <value>Adaptive quantization controls how the encoder distributes bits across the frame.
Higher values take more bits away from edges and complex areas to improve areas with finer detail.</value>
  </data>
  <data name="Advanced_AnalysisToolTip" xml:space="preserve">
    <value>Mode decision picks from a variety of options to make its decision: this option chooses what options those are.  
Fewer partitions to check means faster encoding, at the cost of worse decisions, since the best option might have been one that was turned off.</value>
  </data>
  <data name="Advanced_BFramesToolTip" xml:space="preserve">
    <value>Sane values are ~2-5.  
This specifies the maximum number of sequential B-frames that the encoder can use. 
 Large numbers generally won't help significantly unless Adaptive B-frames is set to Optimal.  
Cel-animated source material and B-pyramid also significantly increase the usefulness of larger values. 
Baseline profile, as required for iPods and similar devices, requires B-frames to be set to 0 (off).</value>
  </data>
  <data name="Advanced_CabacToolTip" xml:space="preserve">
    <value>After the encoder has done its work, it has a bunch of data that needs to be compressed losslessly, similar to ZIP or RAR. H.264 provides two options for this: CAVLC and CABAC.  CABAC decodes a lot slower but compresses significantly better (10-30%), especially at lower bitrates. If you're looking to minimize CPU requirements for video playback, disable this option. Baseline profile, as required for iPods and similar devices, requires CABAC to be disabled.</value>
  </data>
  <data name="Advanced_DeblockingToolTip" xml:space="preserve">
    <value>H.264 has a built-in deblocking filter that smooths out blocking artifacts after decoding each frame.  This not only improves visual quality, but also helps compression significantly. 
The deblocking filter takes a lot of CPU power, so if you're looking to minimize CPU requirements for video playback, disable it.

The deblocking filter has two adjustable parameters, "strength" and "threshold". 
The former controls how strong (or weak) the deblocker is, while the latter controls how many (or few)  edges it applies to. 
Lower values mean less deblocking, higher values mean more deblocking. The default is 0 (normal strength) for both parameters.</value>
  </data>
  <data name="Advanced_EightByEightDctToolTip" xml:space="preserve">
    <value>The 8x8 transform is the single most useful feature of x264 in terms of compression-per-speed.  
It improves compression by at least 5% at a very small speed cost and may provide an unusually high visual quality benefit compared to its compression gain.  
However, it requires High Profile, which many devices may not support.</value>
  </data>
  <data name="Advanced_MotionEstimationMethodToolTip" xml:space="preserve">
    <value>Controls the motion estimation method. Motion estimation is how the encoder estimates how each block of pixels in a frame has moved.  
A better motion search method improves compression at the cost of speed.

Diamond: performs an extremely fast and simple search using a diamond pattern.

Hexagon: performs a somewhat more effective but slightly slower search using a hexagon pattern.

Uneven Multi-Hex: performs a very wide search using a variety of patterns, more accurately capturing complex motion.

Exhaustive: performs a "dumb" search of every pixel in a wide area.  Significantly slower for only a small compression gain.

Transformed Exhaustive: Like exhaustive, but makes even more accurate decisions. Accordingly, somewhat slower, also for only a small improvement.</value>
  </data>
  <data name="Advanced_MotionEstimationRangeToolTip" xml:space="preserve">
    <value>This is the distance x264 searches from its best guess at the motion of a block in order to try to find its actual motion.  

The default is fine for most content, but extremely high motion video, especially at HD resolutions, may benefit from higher ranges, albeit at a high speed cost.</value>
  </data>
  <data name="Advanced_NoDctDecimateToolTip" xml:space="preserve">
    <value>x264 normally zeroes out nearly-empty data blocks to save bits to be better used for some other purpose in the video.  
However, this can sometimes have slight negative effects on retention of subtle grain and dither.  
Don't touch this unless you're having banding issues or other such cases where you are having trouble keeping fine noise.</value>
  </data>
  <data name="Advanced_PsychovisualRateDistortionToolTip" xml:space="preserve">
    <value>Psychovisual Rate Distortion means x264 tries to retain detail, for better quality to the human eye, 
as opposed to trying to maximize quality the way a computer understands it, through signal-to-noise ratios that have trouble telling apart fine detail and noise.</value>
  </data>
  <data name="Advanced_PsychovisualTrellisToolTip" xml:space="preserve">
    <value>Psychovisual Trellis tries to retain more sharpness and detail, but can cause artifacting.
It is considered experimental, which is why it's off by default. Good values are 0.1 to 0.2.</value>
  </data>
  <data name="Advanced_PyramidalBFramesToolTip" xml:space="preserve">
    <value>B-pyramid improves compression by creating a pyramidal structure (hence the name) of B-frames, allowing B-frames to 
reference each other to improve compression.  

Requires Max B-frames greater than 1; optimal adaptive B-frames is strongly recommended for full compression benefit.</value>
  </data>
  <data name="Advanced_ReferenceFramesToolTip" xml:space="preserve">
    <value>Sane values are ~1-6.

The more you add, the better the compression, but the slower the encode.

Cel animation tends to benefit from more reference frames a lot more than film content.

Note that many hardware devices have limitations on the number of supported reference frames, so if you're encoding for a handheld or standalone player, don't touch this unless you're absolutely sure you know what you're doing!</value>
  </data>
  <data name="Advanced_SubpixelMotionEstimationToolTip" xml:space="preserve">
    <value>This setting controls both subpixel-precision motion estimation and mode decision methods.

Subpixel motion estimation is used for refining motion estimates beyond mere pixel accuracy, improving compression.

Mode decision is the method used to choose how to encode each block of the frame: a very important decision.

SAD is the fastest method, followed by SATD, RD, RD refinement, and the slowest, QPRD.
6 or higher is strongly recommended: Psy-RD, a very powerful psy optimization that helps retain detail, requires RD.
10, the most powerful and slowest option, requires trellis=2.</value>
  </data>
  <data name="Advanced_TrellisToolTip" xml:space="preserve">
    <value>Trellis fine-tunes the rounding of transform coefficients to squeeze out 3-5% more compression at the cost of some speed. 
"Always" uses trellis not only during the main encoding process, but also during analysis, which improves compression even more, albeit at great speed cost. 

Trellis costs more speed at higher bitrates.</value>
  </data>
  <data name="Advanced_WeightPToolTip" xml:space="preserve">
    <value>Performs extra analysis to decide upon weighting parameters for each frame.  
This improves overall compression slightly and improves the quality of fades greatly. 
Baseline profile, as required for iPods and similar devices, requires weighted P-frame prediction to be disabled.  
Note that some devices and players, even those that support Main Profile, 
may have problems with Weighted P-frame prediction: the Apple TV is completely incompatible with it, for example.</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="logo64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\logo64.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="Video_x264ExtraArgs" xml:space="preserve">
    <value>The full x264 list of parameters: 
{0}</value>
  </data>
  <data name="Video_x264FastDecode" xml:space="preserve">
    <value>Reduce decoder CPU usage.

Set this if your device is struggling to play the output. (i.e. dropped frames)</value>
  </data>
  <data name="Video_x264Level" xml:space="preserve">
    <value>Sets and ensures compliance with the specified H.264 Levels. This will override all other settings.</value>
  </data>
  <data name="Video_x264Preset" xml:space="preserve">
    <value>Adjusts x264 settings to trade off compression efficiency against encoding speed.

This establishes your default x264 settings. Tunes, profiles, levels and advanced options string will be applied to this.

You should generally set this option to the slowest you can bear since slower settings will result in better quality or smaller files.</value>
  </data>
  <data name="Video_x264Profile" xml:space="preserve">
    <value>Limit the H.264 profile of the output stream. This will override all other settings.</value>
  </data>
  <data name="Video_x264Tune" xml:space="preserve">
    <value>Tune settings to optimise for common scenarios

This can improve efficiency for particular source characteristics or set of characteristics of the output file.

Changes will be applied after the preset but before all other parameters.</value>
  </data>
  <data name="Video_QualitySlider" xml:space="preserve">
    <value>Set the desired quality factor. The encoder targets a certain quality. 
The scale used by each video encoder is different.

x264's scale is logarithmic and lower values correspond to higher quality. 
So small increases in value will result in progressively larger increases in the resulting file size. 
A value of 0 means lossless and will result in a file size that is larger than the original source, 
unless the source was also lossless. 
Suggested values are: 18 to 20 for Standard Definition and 20 to 23 for High Definition.

FFMpeg's and Theora's scale is more linear. These encoders do not have a lossless mode.</value>
  </data>
  <data name="Video_LosslessWarning" xml:space="preserve">
    <value>Warning: RF 0 is Lossless!</value>
  </data>
  <data name="Video_LosslessWarningTooltip" xml:space="preserve">
    <value>A value of 0 means lossless and will result in a file size that is larger than the original source, 
unless the source was also lossless. 

x264's scale is logarithmic and lower values correspond to higher quality. 

So small increases in value will result in progressively larger increases in the resulting file size. 

Suggested values are: 18 to 20 for Standard Definition and 20 to 23 for High Definition.</value>
  </data>
  <data name="AddPreset_PictureSizeMode" xml:space="preserve">
    <value>You can optionally store a maximum resolution for encodes that use this preset. There are 4 modes:

None:  There is no maximum resolution for encodes using this preset. When the preset is loaded, the current width, height and aspect ratio that you currently have set will be reloaded.

Custom: You can optionally set a Maximum width and Height. When doing this an encode will be less than or equal to these values. Keep Aspect Ratio will be automatically turned on.

Source Maximum:  Similar to custom, but the resolution of your current source is used as the Max width and Height values instead. Keep Aspect Ratio will be automatically turned on.</value>
  </data>
  <data name="Advanced_EncoderOptions" xml:space="preserve">
    <value>The options passed to the x264 encoder. 
The above controls are only a subset of useful x264 parameters. 
This box allows you to add or modify additional or current parameters as desired. </value>
  </data>
  <data name="About_GPL" xml:space="preserve">
    <value>Copyright (C) 2003-2013 The HandBrake Team

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</value>
  </data>
  <data name="Advanced_NotInUse" xml:space="preserve">
    <value>The x264 Preset / Tune / Profile and Level options are currently in use on the Video Tab. 

To enable this tab, check the "Use Advanced Tab instead" option on the Video Tab.

If you do not use this tab, it can be hidden from: Tools Menu &gt; Options &gt; Advanced.</value>
  </data>
  <data name="QueueSelection_AutoNameWarning" xml:space="preserve">
    <value>WARNING: You do not have automatic file naming turned on. Please enable this in options.</value>
  </data>
  <data name="QueueSelection_AutoTrackSelectionWarning" xml:space="preserve">
    <value>WARNING: You do not currently have automatic audio and subtitle track selection setup. You can setup the default track selection behaviour in options.</value>
  </data>
  <data name="Presets_ResetComplete" xml:space="preserve">
    <value>The Built-in presets have been reset.</value>
  </data>
  <data name="Presets_ResetHeader" xml:space="preserve">
    <value>Reset Complete</value>
  </data>
  <data name="Video_HigherQuality" xml:space="preserve">
    <value>Higher Quality |</value>
  </data>
  <data name="Video_LowQuality" xml:space="preserve">
    <value>| Lower Quality</value>
  </data>
  <data name="Video_PlaceboQuality" xml:space="preserve">
    <value>Placebo Quality |</value>
  </data>
  <data name="Video_DxvaDecode" xml:space="preserve">
    <value>Please note, this option is suitable only for slower systems. It will cause a bottleneck on faster systems.
Accelerates H.264, MPEG-4, VC1 and WMV3 only. </value>
  </data>
  <data name="Video_QuickSyncNotAvailable" xml:space="preserve">
    <value>QuickSync hardware not detected! 

In order to use the QuickSync encoder, you must:

- Have a Intel Core series CPU with HD Graphics. 4th Generation Haswell or newer parts are recommended for best quality.
- Have a monitor connected to the HD Graphics or GPU Virtualisation software installed.
- Note that in multi-GPU enviroments, you may need to use 3rd party tools and workarounds to active the hardware.</value>
  </data>
  <data name="Video_ScalingModes" xml:space="preserve">
    <value>Lanczos                - This is HandBrakes default scaler. It provides the best quality downscaling.
Bicubic OpenCL  - A hardware accelerated version of the CPU based Bicubic scaler. 
                                 This can be around 5~7% faster than software bicubic on a fast modern graphics card.
                                 If OpenCL is unavailable, it will fallback to a software scaler. </value>
  </data>
</root>